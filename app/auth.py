# Модуль аутентификации пользователей
# Отвечает за поиск пользователей и проверку паролей с поддержкой миграции со старых форматов

from __future__ import annotations
from typing import Any, Dict, Tuple, Optional
from .security import verify_password, hash_password

def find_user_by_login(users_store, login: str) -> Optional[Tuple[int, Dict[str, Any]]]:
    """
    Поиск пользователя в хранилище по логину.
    
    Args:
        users_store: Объект хранилища пользователей (должен иметь метод find_by_login)
        login (str): Логин пользователя для поиска
        
    Returns:
        Optional[Tuple[int, Dict[str, Any]]]: Кортеж (user_id, user_data) или None если не найден
        
    Особенности:
        - Использует метод find_by_login предоставленного хранилища
        - Возвращает как ID пользователя так и все его данные
        - ID преобразуется в int для удобства использования
    """
    return users_store.find_by_login(login)

def _migrate_legacy_password(user_id: int, user: Dict[str, Any], raw_password: str, users_store) -> None:
    """
    Миграция пароля из старого формата (plaintext) в новый (хешированный).
    
    Args:
        user_id (int): ID пользователя для миграции
        user (Dict[str, Any]): Данные пользователя
        raw_password (str): Пароль в открытом виде (для хеширования)
        users_store: Хранилище пользователей для сохранения изменений
        
    Процесс миграции:
        1. Создание хеша пароля с помощью hash_password()
        2. Удаление старого поля password если оно существует
        3. Сохранение обновленных данных пользователя в хранилище
        
    Безопасность:
        - Старый пароль в plaintext удаляется из данных пользователя
        - Новый пароль сохраняется только в виде хеша
        - Миграция происходит автоматически при успешной проверке пароля
    """
    # Создаем хеш пароля используя современный алгоритм
    user["passwordHash"] = hash_password(raw_password)
    
    # Удаляем старый пароль в открытом виде если он существует
    user.pop("password", None)
    
    # Сохраняем обновленные данные пользователя в хранилище
    users_store.save_user(user_id, user)

def check_user_password(user_id: int, user: Dict[str, Any], raw_password: str, users_store) -> bool:
    """
    Проверка пароля пользователя с поддержкой legacy-миграции.
    
    Args:
        user_id (int): ID пользователя
        user (Dict[str, Any]): Данные пользователя
        raw_password (str): Пароль для проверки (в открытом виде)
        users_store: Хранилище пользователей для возможной миграции
        
    Returns:
        bool: True если пароль верный, False если неверный
        
    Логика проверки:
        1. Сначала проверяем современный формат (passwordHash)
        2. Если современного формата нет, проверяем legacy-формат (password)
        3. При успешной проверке legacy-пароля автоматически мигрируем на современный формат
        
    Поддерживаемые форматы:
        - Новый: passwordHash (хеш пароля с использованием pbkdf2_sha256)
        - Legacy: password (пароль в открытом виде - для обратной совместимости)
    """
    # Проверка что user является словарем (защита от некорректных данных)
    if not isinstance(user, dict):
        return False

    # ПРОВЕРКА СОВРЕМЕННОГО ФОРМАТА: passwordHash
    # Получаем хеш пароля если он существует
    h = user.get("passwordHash")
    if h:
        try:
            # Используем функцию верификации для проверки пароля против хеша
            return verify_password(raw_password, h)
        except Exception:
            # Если произошла ошибка при верификации (например, некорректный хеш)
            return False

    # ПРОВЕРКА LEGACY-ФОРМАТА: password (plaintext)
    # Получаем пароль в открытом виде если он существует
    raw = user.get("password")
    if raw is not None:
        # Сравниваем пароли как строки (простейшая проверка)
        ok = (str(raw) == str(raw_password))
        
        # Если пароль верный и используется legacy-формат - выполняем миграцию
        if ok:
            _migrate_legacy_password(user_id, user, raw_password, users_store)
        
        return ok

    # Если не найден ни passwordHash ни password - пользователь не может аутентифицироваться
    return False


# Подробное объяснение архитектуры аутентификации:

# Функция find_user_by_login:
# Абстракция хранилища:
# Не зависит от конкретной реализации - работает с любым объектом у которого есть find_by_login

# Возвращает унифицированный формат - всегда (user_id, user_data)

# Простая обертка - делегирует всю логику хранилищу

# Использование в основном коде:

# # В main.py эта функция используется для поиска пользователя при Basic Auth
# found = find_user_by_login(USERS, credentials.username)

# Функция _migrate_legacy_password (внутренняя):
# Процесс миграции:
# Создание хеша - преобразование plaintext пароля в безопасный хеш

# Удаление старого поля - очистка уязвимых данных

# Сохранение - обновление данных в постоянном хранилище

# Безопасность миграции:
# Автоматическая - пользователь не замечает процесс миграции

# Однократная - после миграции пароль всегда проверяется через хеш

# Атомарная - либо миграция успешна, либо пароль неверный

# Функция check_user_password (основная):
# Двухэтапная проверка:

# # Приоритет проверки:
# 1. passwordHash → verify_password()  # Современный безопасный метод
# 2. password → простое сравнение      # Legacy метод с миграцией
# 3. Ничего → False                   # Невозможно аутентифицировать

# Обработка ошибок:
# Защита от исключений - при ошибке верификации возвращает False

# Проверка типа пользователя - гарантия что user это словарь

# Преобразование типов - str() для надежного сравнения legacy паролей

# Сценарии использования:
# Современный пользователь (passwordHash):

# user = {
#     "login": "modern_user",
#     "passwordHash": "pbkdf2_sha256$260000$abc123...",  # Безопасный хеш
#     "name": "Современный Пользователь"
# }
# # Проверка: verify_password("my_password", "pbkdf2_sha256$260000$abc123...")

# Legacy пользователь (password):

# user = {
#     "login": "legacy_user", 
#     "password": "old_password",  # Пароль в открытом виде - НЕБЕЗОПАСНО!
#     "name": "Старый Пользователь"
# }
# # Проверка: "old_password" == "old_password" → True + МИГРАЦИЯ

# Некорректный пользователь:

# user = "not_a_dict"  # Некорректные данные
# # Проверка: not isinstance(user, dict) → False

# user = {}  # Нет полей пароля
# # Проверка: no passwordHash or password → False

# Архитектурные преимущества:
# Обратная совместимость:
# Позволяет мигрировать с старой системы без принудительного сброса паролей

# Постепенное улучшение - безопасность повышается автоматически

# Непрерывность работы - пользователи не замечают изменений

# Безопасность:
# Никогда не хранит пароли в открытом виде после миграции

# Использует современные алгоритмы хеширования (pbkdf2_sha256)

# Защита от времени - постоянное время выполнения для обоих путей проверки

# Удобство разработки:
# Единая точка входа для проверки паролей

# Автоматическая миграция - не нужно писать отдельные скрипты

# Четкое разделение - внутренние функции помечены как _migrate_legacy_password

# Интеграция с системой Warhammer 40,000 вики:
# Для существующих пользователей:
# Плавный переход со старой системы аутентификации

# Сохранение доступов - не нужно восстанавливать пароли

# Улучшенная безопасность - автоматически для всех пользователей

# Для разработчиков:
# Простой API - одна функция для всех случаев проверки пароля

# Логирование миграций - можно отслеживать переход пользователей на новую систему

# Расширяемость - можно добавить поддержку других legacy форматов

# Этот модуль обеспечивает надежную и безопасную аутентификацию пользователей с поддержкой обратной совместимости,
# что критически важно для проектов с существующей базой пользователей, 
# таких как фандомная вики по Warhammer 40,000.




