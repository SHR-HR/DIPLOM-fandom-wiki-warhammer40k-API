# Импорт аннотаций из будущих версий Python для улучшенной поддержки типизации
from __future__ import annotations

# Импорт стандартных библиотек Python
import json  # Для работы с JSON данными
from pathlib import Path  # Для удобной работы с путями файловой системы
from fastapi import Query  # Для работы с query-параметрами в URL
from typing import List, Optional, Literal, Dict, Any, Tuple  # Для типизации данных
from uuid import uuid4  # Для генерации уникальных идентификаторов

# Импорт сторонних библиотек
import httpx  # Асинхронный HTTP-клиент для внешних запросов
from fastapi import FastAPI, HTTPException, UploadFile, File, status, Depends  # Основные компоненты FastAPI
from fastapi.middleware.cors import CORSMiddleware  # Middleware для CORS (междоменных запросов)
from fastapi.staticfiles import StaticFiles  # Для раздачи статических файлов
from fastapi.security import HTTPBasic, HTTPBasicCredentials  # Для Basic аутентификации
from pydantic import BaseModel, Field  # Для валидации данных и создания моделей

# Импорт собственных модулей приложения
from app.auth import find_user_by_login, check_user_password  # Функции аутентификации
from app.security import hash_password  # Функция хеширования паролей
# Функция для удаления локальных загруженных изображений
from app.utils.images import delete_local_uploads  # используем твою текущую версию (возвращает list[str] или (removed, candidates))

# ===== КОНСТАНТЫ И ПУТИ =====
# Определение корневой директории приложения (где находится main.py)
APP_DIR = Path(__file__).parent.resolve()

# Создание пути к директории данных (J:\MAIN_DIP-М\API\data)
DATA_DIR = APP_DIR / "data"

# Создание пути к директории для загруженных файлов (J:\MAIN_DIP-М\API\data\uploads)
UPLOAD_DIR = DATA_DIR / "uploads"

# Путь к файлу со статьями (J:\MAIN_DIP-М\API\data\articles.json)
ARTICLES_FILE = DATA_DIR / "articles.json"
ARTICLES_PATH = DATA_DIR / "articles.json"  # Дублирование для совместимости

# Путь к файлу с пользователями (J:\MAIN_DIP-М\API\data\users.json)
USERS_FILE = DATA_DIR / "users.json"

# Множество разрешенных расширений для загружаемых изображений
ALLOWED_EXTS = {".jpg", ".jpeg", ".png", ".webp", ".gif", ".svg"}

# Максимальный размер файла для загрузки в памяти (5 МБ согласно техническому заданию)
MAX_INMEMORY = 5 * 1024 * 1024  # 5 MB по ТЗ

# ===== ИНИЦИАЛИЗАЦИЯ ФАЙЛОВОЙ СИСТЕМЫ =====
# создаём директории/файлы при первом старте

# Создание директории data если она не существует
# parents=True - создает все родительские директории если их нет
# exist_ok=True - не вызывает ошибку если директория уже существует
DATA_DIR.mkdir(parents=True, exist_ok=True)

# Создание директории uploads для хранения загруженных файлов
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

# Создание файла articles.json если он не существует
# Записываем пустой массив [] как начальное значение
if not ARTICLES_FILE.exists():
    ARTICLES_FILE.write_text("[]", encoding="utf-8")

# Создание файла users.json если он не существует  
# Записываем пустой объект {} как начальное значение
if not USERS_FILE.exists():
    USERS_FILE.write_text("{}", encoding="utf-8")

# Подробное объяснение структуры:
# Импорты:
# Стандартные библиотеки: обеспечивают базовую функциональность (работа с JSON, путями, типами)

# FastAPI компоненты: framework для создания API (роутинг, валидация, аутентификация)

# Pydantic: для создания моделей данных с автоматической валидацией

# Собственные модули: бизнес-логика приложения (аутентификация, безопасность, работа с изображениями)

# Константы и пути:
# APP_DIR: автоматически определяет корневую директорию приложения

# DATA_DIR: централизованное хранение всех данных приложения

# UPLOAD_DIR: специальная папка для пользовательских загрузок

# ALLOWED_EXTS: защита от загрузки нежелательных типов файлов

# MAX_INMEMORY: ограничение размера файлов согласно ТЗ

# Инициализация:
# Автоматическое создание структуры: приложение самодостаточно и создает нужные папки при первом запуске

# Начальные файлы: гарантируют, что приложение не упадет при обращении к несуществующим файлам

# Эта часть кода отвечает за базовую настройку приложения и подготовку файловой системы для работы.

# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================





# ===== УТИЛИТЫ ХРАНИЛИЩА =====
# Этот раздел содержит функции и классы для работы с файловым хранилищем данных

def _read_json(path: Path, default):
    """
    Внутренняя функция для безопасного чтения JSON файлов.
    
    Args:
        path (Path): Путь к JSON файлу который нужно прочитать
        default: Значение которое вернется если файл не существует или поврежден
    
    Returns:
        Данные из JSON файла или значение default при ошибке
    
    Особенности:
        - Использует utf-8 кодировку для поддержки кириллицы
        - Ловит все исключения чтобы приложение не падало из-за проблем с файлами
    """
    try:
        # Читаем весь текст файла и преобразуем JSON в Python объект
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        # При любой ошибке возвращаем значение по умолчанию
        return default

def _write_json(path: Path, data):
    """
    Внутренняя функция для безопасной записи данных в JSON файл.
    
    Args:
        path (Path): Путь к файлу для записи
        data: Данные для записи (любой объект сериализуемый в JSON)
    
    Особенности:
        - ensure_ascii=False позволяет сохранять кириллицу без escape-последовательностей
        - indent=2 для красивого форматирования и читаемости файла
        - Автоматически создает директории если их нет
    """
    # Создаем родительские директории если они не существуют
    path.parent.mkdir(parents=True, exist_ok=True)
    # Записываем данные с красивым форматированием
    path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")

def load_articles() -> List[Dict[str, Any]]:
    """
    Загрузка всех статей из файла хранилища.
    
    Returns:
        List[Dict[str, Any]]: Список всех статей, где каждая статья - словарь с данными
        
    Особенности:
        - Если файл не существует или поврежден, возвращает пустой список
        - Используется во всех операциях чтения статей
    """
    return _read_json(ARTICLES_FILE, [])

def save_articles(items: List[Dict[str, Any]]) -> None:
    """
    Сохранение списка статей в файл хранилища.
    
    Args:
        items (List[Dict[str, Any]]): Полный список статей для сохранения
        
    Использование:
        - Вызывается после любых изменений в статьях (создание, обновление, удаление)
    """
    _write_json(ARTICLES_FILE, items)

def next_id(items: List[Dict[str, Any]]) -> int:
    """
    Генерация следующего уникального ID для новой статьи.
    
    Args:
        items (List[Dict[str, Any]]): Существующий список статей
        
    Returns:
        int: Следующий доступный ID (максимальный существующий ID + 1)
        
    Логика работы:
        - Проходит по всем статьям и находит максимальный ID
        - Обрабатывает некорректные ID (преобразует в int с обработкой исключений)
        - Если статей нет, возвращает 1
    """
    maxi = 0
    for it in items:
        try:
            # Пытаемся получить ID статьи и преобразовать к числу
            maxi = max(maxi, int(it.get("id", 0)))
        except Exception:
            # Если ID некорректный (не число), просто пропускаем
            pass
    return maxi + 1

class UsersStore:
    """
    Класс для управления хранилищем пользователей.
    
    Хранилище представляет собой JSON файл со структурой:
    {
        "1": {"login": "user1", "name": "User One", ...},
        "2": {"login": "user2", "name": "User Two", ...}
    }
    
    Ключи - строковые представления ID пользователей, значения - объекты пользователей.
    """
    
    def __init__(self, path: Path):
        """
        Инициализация хранилища пользователей.
        
        Args:
            path (Path): Путь к файлу users.json
        """
        self.path = path

    def load_all(self) -> Dict[str, Dict[str, Any]]:
        """
        Загрузка всех пользователей из файла.
        
        Returns:
            Dict[str, Dict[str, Any]]: Словарь всех пользователей, 
            где ключ - ID пользователя (str), значение - данные пользователя
        """
        return _read_json(self.path, {})

    def save_all(self, data: Dict[str, Dict[str, Any]]):
        """
        Сохранение всех пользователей в файл.
        
        Args:
            data (Dict[str, Dict[str, Any]]): Полный словарь пользователей для сохранения
        """
        _write_json(self.path, data)

    def get(self, user_id: int) -> Dict[str, Any] | None:
        """
        Получение пользователя по числовому ID.
        
        Args:
            user_id (int): ID пользователя
            
        Returns:
            Dict[str, Any] | None: Данные пользователя или None если не найден
            
        Особенности:
            - Преобразует числовой ID в строку для поиска в хранилище
        """
        data = self.load_all()
        return data.get(str(user_id))

    def save_user(self, user_id: int, user_obj: Dict[str, Any]) -> None:
        """
        Сохранение или полная замена данных пользователя.
        
        Args:
            user_id (int): ID пользователя
            user_obj (Dict[str, Any]): Полные данные пользователя
            
        Использование:
            - Используется при создании нового пользователя
            - Полностью заменяет существующие данные
        """
        data = self.load_all()
        # Преобразуем в dict для гарантии что это словарь (а не например Pydantic модель)
        data[str(user_id)] = dict(user_obj)
        self.save_all(data)

    def upsert(self, user_id: int, patch: Dict[str, Any]) -> Dict[str, Any]:
        """
        Частичное обновление данных пользователя (update or insert).
        
        Args:
            user_id (int): ID пользователя
            patch (Dict[str, Any]): Словарь с полями для обновления
            
        Returns:
            Dict[str, Any]: Обновленные данные пользователя
            
        Логика работы:
            - Если пользователь существует - обновляет только переданные поля
            - Если пользователя нет - создает нового с указанными полями
            - Сохраняет неизменными поля которые не были переданы в patch
        """
        data = self.load_all()
        # Получаем текущие данные или пустой словарь если пользователя нет
        cur = data.get(str(user_id), {})
        # Обновляем только переданные поля
        cur.update(patch)
        # Сохраняем обратно
        data[str(user_id)] = cur
        self.save_all(data)
        return cur

    def find_by_login(self, login: str) -> Optional[Tuple[int, Dict[str, Any]]]:
        """
        Поиск пользователя по логину.
        
        Args:
            login (str): Логин для поиска
            
        Returns:
            Optional[Tuple[int, Dict[str, Any]]]: Кортеж (user_id, user_data) или None
            
        Особенности:
            - Возвращает числовой ID и данные пользователя
            - Используется при аутентификации
        """
        data = self.load_all()
        for k, u in data.items():
            # Проверяем что данные пользователя - словарь и логин совпадает
            if isinstance(u, dict) and u.get("login") == login:
                try:
                    # Преобразуем строковый ключ в числовой ID
                    return int(k), u
                except Exception:
                    # Если ключ не число - пропускаем этого пользователя
                    continue
        return None

    def login_exists(self, login: str) -> bool:
        """
        Проверка существования пользователя с указанным логином.
        
        Args:
            login (str): Логин для проверки
            
        Returns:
            bool: True если пользователь с таким логином уже существует
            
        Использование:
            - При регистрации новых пользователей для проверки уникальности логина
        """
        return self.find_by_login(login) is not None

    def next_user_id(self) -> int:
        """
        Генерация следующего уникального ID для нового пользователя.
        
        Returns:
            int: Следующий доступный ID пользователя
            
        Логика работы:
            - Анализирует все ключи в хранилище как числа
            - Находит максимальный существующий ID
            - Возвращает максимальный ID + 1
        """
        data = self.load_all()
        maxi = 0
        for k in data.keys():
            try:
                # Пытаемся преобразовать ключ в число и найти максимум
                maxi = max(maxi, int(k))
            except Exception:
                # Если ключ не число - пропускаем
                pass
        return maxi + 1

# Создание глобального экземпляра хранилища пользователей
# Этот объект используется во всем приложении для работы с пользователями
USERS = UsersStore(USERS_FILE)

# Подробное объяснение архитектуры хранилища:
# Функции работы с JSON:
# _read_json и _write_json - низкоуровневые утилиты для безопасной работы с файлами

# Обработка ошибок - гарантируют что приложение не упадет при проблемах с файлами

# Кодировка UTF-8 - поддержка кириллических символов в данных

# Функции для статей:
# load_articles() - загрузка всех статей для операций чтения

# save_articles() - сохранение после изменений

# next_id() - генерация ID вручную (так как нет базы данных с автоинкрементом)

# Класс UsersStore:
# Инкапсуляция логики - весь код работы с пользователями в одном классе

# CRUD операции - создание, чтение, обновление, удаление пользователей

# Поиск по логину - критично для системы аутентификации

# Валидация уникальности - предотвращает дублирование логинов

# Паттерн проектирования:
# Repository Pattern - абстрагирует работу с хранилищем от бизнес-логики

# Единая точка доступа - глобальный объект USERS для всего приложения

# Согласованность данных - все операции проходят через одни и те же методы

# Этот код обеспечивает надежное хранение данных в файловой системе с защитой от потерь данных и обработкой edge-cases.

# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================





# ===== МОДЕЛИ ДАННЫХ PYDANTIC =====
# Этот раздел содержит все модели данных (схемы) используемые в API
# Pydantic модели обеспечивают валидацию данных, автоматическую документацию и типобезопасность

class MainInfo(BaseModel):
    """
    Модель основной информации о персонаже/сущности вселенной Warhammer 40,000.
    
    Содержит основные характеристики, которые могут быть у персонажа, фракции или единицы:
    - Биографические данные (имя, возраст, дата рождения, пол)
    - Внешние характеристики (внешность, рост, вес)
    - Дополнительные произвольные данные в словаре other
    
    Все поля опциональны, так как не у всех сущностей есть полный набор характеристик.
    """
    name: Optional[str] = None           # Имя персонажа/сущности
    image: Optional[str] = None          # URL основного изображения
    age: Optional[int] = None            # Возраст (в годах или иных единицах)
    birthday: Optional[str] = None       # Дата рождения (строка в свободном формате)
    gender: Optional[str] = None         # Пол (может быть "Male", "Female", "Unknown" и т.д.)
    appearance: Optional[str] = None     # Текстовое описание внешности
    height: Optional[str] = None         # Рост (строка, например "2.5m" или "8ft")
    weight: Optional[str] = None         # Вес (строка, например "150kg" или "330lbs")
    other: Optional[Dict[str, Any]] = None  # Дополнительные характеристики в свободной форме

# Определение допустимых типов контентных блоков для статей
# Literal означает что поле может принимать только указанные строковые значения
BlockType = Literal["h1", "h2", "h3", "p", "image", "ul", "li"]

class ContentItem(BaseModel):
    """
    Модель отдельного блока контента в статье.
    
    Представляет структурную единицу содержимого статьи - абзац, заголовок, изображение, список.
    Система блоков позволяет создавать структурированные статьи с разным типом контента.
    
    Attributes:
        type: Тип блока определяет его отображение и назначение
        content: Содержимое блока, тип зависит от типа блока:
            - для "p", "h1", "h2", "h3": строка с текстом
            - для "image": URL изображения
            - для "ul": список объектов ContentItem с type="li"
            - для "li": строка с элементом списка
    """
    type: BlockType
    content: Any  # для ul: список элементов { "type": "li", "content": "..." }

class Article(BaseModel):
    """
    Полная модель статьи википедии по вселенной Warhammer 40,000.
    
    Статья представляет собой законченную запись о персонаже, фракции, событии или объекте.
    Содержит мета-информацию, основную информацию о сущности и структурированное содержимое.
    
    Attributes:
        id: Уникальный числовой идентификатор статьи (обязательное поле)
        author: Имя автора статьи (для отображения)
        author_id: ID автора статьи (для связи с пользователем)
        title: Заголовок статьи (обязательное поле)
        previewImg: URL изображения для превью в списках
        mainInfo: Основная информация о сущности (характеристики)
        mainContent: Структурированное содержимое статьи в виде блоков
    """
    id: int
    author: Optional[str] = None
    author_id: Optional[int] = None
    title: str
    previewImg: Optional[str] = None
    mainInfo: Optional[MainInfo] = None
    mainContent: Optional[List[ContentItem]] = None

class ArticleCreate(BaseModel):
    """
    Модель для создания новой статьи (без ID).
    
    Используется при POST запросах на создание статьи.
    ID генерируется автоматически сервером, поэтому отсутствует в этой модели.
    
    Отличается от Article только отсутствием обязательного поля id.
    """
    author: Optional[str] = None
    author_id: Optional[int] = None
    title: str
    previewImg: Optional[str] = None
    mainInfo: Optional[MainInfo] = None
    mainContent: Optional[List[ContentItem]] = None

class ArticlePatch(BaseModel):
    """
    Модель для частичного обновления статьи.
    
    Используется при PATCH запросах для обновления только указанных полей.
    Все поля опциональны - клиент может передать только те поля, которые нужно обновить.
    
    Особенности:
        - exclude_unset=True при использовании model_dump() игнорирует не переданные поля
        - Позволяет обновлять отдельные поля без отправки всей статьи
    """
    author: Optional[str] = None
    author_id: Optional[int] = None
    title: Optional[str] = None
    previewImg: Optional[str] = None
    mainInfo: Optional[MainInfo] = None
    mainContent: Optional[List[ContentItem]] = None

class UserUpdate(BaseModel):
    """
    Модель для обновления данных пользователя.
    
    Используется для изменения имени и аватара пользователя.
    Оба поля опциональны - можно обновлять по отдельности.
    
    Attributes:
        name: Новое имя пользователя (отображаемое имя)
        ava: URL аватара (может быть локальным /uploads/... или внешним)
    """
    name: str | None = None
    ava: str | None = None  # URL или локальный /uploads/...

class RegisterPayload(BaseModel):
    """
    Модель данных для регистрации нового пользователя.
    
    Содержит все необходимые данные для создания учетной записи.
    Все основные поля обязательны (min_length=1 гарантирует непустые строки).
    
    Attributes:
        name: Отображаемое имя пользователя
        login: Уникальный логин для входа
        password: Пароль (будет захэширован перед сохранением)
        email: Email пользователя (опционально)
        ava: URL аватара (опционально, будет использован стандартный если не указан)
    """
    name: str = Field(..., min_length=1)  # Field с ... означает обязательное поле
    login: str = Field(..., min_length=1)
    password: str = Field(..., min_length=1)
    email: str | None = None
    ava: str | None = None

class LoginPayload(BaseModel):
    """
    Модель данных для авторизации пользователя.
    
    Используется при входе в систему через эндпоинт /login.
    
    Attributes:
        login: Логин пользователя
        password: Пароль пользователя (в открытом виде, будет проверен с хэшем)
    """
    login: str
    password: str


# ===== СОЗДАНИЕ И НАСТРОЙКА FASTAPI ПРИЛОЖЕНИЯ =====

# Создание основного экземпляра FastAPI приложения
# title отображается в автоматической документации Swagger UI
app = FastAPI(title="deep_lom_ka API (PROJECT-DEEP_LOO_MKA)")

# Настройка CORS (Cross-Origin Resource Sharing) для фронтенда
# CORS необходим чтобы браузер разрешал запросы с фронтенда на бэкенд с разных доменов/портов
app.add_middleware(
    CORSMiddleware,
    # Список разрешенных источников (origin) - домены с которых можно делать запросы
    allow_origins=[
        "http://localhost:4173",  # Vite preview server (продакшен сборка)
        "http://127.0.0.1:4173",  # Альтернативный адрес preview сервера
        "http://localhost:5173",   # Vite dev server (разработка с горячей перезагрузкой)
        "http://127.0.0.1:5173",  # Альтернативный адрес dev сервера
    ],
    allow_credentials=True,  # Разрешает отправку cookies и авторизационных заголовков
    allow_methods=["*"],     # Разрешает все HTTP методы (GET, POST, PUT, DELETE и т.д.)
    allow_headers=["*"],     # Разрешает все HTTP заголовки
)

# Настройка статической раздачи загруженных файлов
# Все файлы в директории UPLOAD_DIR будут доступны по URL начинающимся с /uploads/
# Например: файл J:\MAIN_DIP-М\API\data\uploads\image.jpg будет доступен по /uploads/image.jpg
app.mount("/uploads", StaticFiles(directory=str(UPLOAD_DIR)), name="uploads")


# ===== BASIC AUTH DEPENDENCY =====

# Создание экземпляра HTTPBasic аутентификации
# auto_error=False означает что при отсутствии credentials не будет автоматической ошибки
security = HTTPBasic(auto_error=False)

def get_current_user(credentials: HTTPBasicCredentials = Depends(security)) -> Tuple[int, Dict[str, Any]]:
    """
    Dependency функция для получения текущего аутентифицированного пользователя.
    
    Эта функция используется как dependency в защищенных эндпоинтах через Depends().
    Она автоматически вызывается FastAPI для каждого запроса к защищенным эндпоинтам.
    
    Args:
        credentials: Данные Basic аутентификации (логин и пароль) из заголовка Authorization
        
    Returns:
        Tuple[int, Dict[str, Any]]: Кортеж из ID пользователя и его данных
        
    Raises:
        HTTPException: 401 если аутентификация не пройдена
        
    Логика работы:
        1. Проверяет что credentials предоставлены
        2. Ищет пользователя по логину в хранилище
        3. Проверяет корректность пароля
        4. Возвращает данные пользователя если все проверки пройдены
    """
    # Проверка что credentials предоставлены
    if credentials is None:
        raise HTTPException(
            status_code=401, 
            detail="Unauthorized", 
            headers={"WWW-Authenticate": "Basic"}  # Сообщает браузеру запросить аутентификацию
        )
    
    # Поиск пользователя по логину в хранилище USERS
    found = find_user_by_login(USERS, credentials.username)
    if not found:
        raise HTTPException(
            status_code=401, 
            detail="Неверные учетные данные", 
            headers={"WWW-Authenticate": "Basic"}
        )
    
    # Распаковка найденных данных пользователя
    user_id, user = found
    
    # Проверка пароля (включая миграцию со старых plaintext паролей)
    if not check_user_password(user_id, user, credentials.password, USERS):
        raise HTTPException(
            status_code=401, 
            detail="Неверные учетные данные", 
            headers={"WWW-Authenticate": "Basic"}
        )
    
    # Возврат данных аутентифицированного пользователя
    return user_id, user


# Подробное объяснение архитектуры:
# Модели данных Pydantic:
# MainInfo - Характеристики сущностей Warhammer 40,000:
# Универсальная модель для любых сущностей вселенной (персонажи, фракции, техника)

# Гибкая структура позволяет описывать разнородные объекты

# Поле other для расширяемости и кастомных характеристик

# Система контентных блоков:
# BlockType - ограниченный набор допустимых типов контента

# ContentItem - универсальный блок для структурированного содержимого

# Поддержка иерархических структур (списки внутри списков)

# Статьи и операции:
# Article - полная модель для чтения (с ID)

# ArticleCreate - для создания (без ID)

# ArticlePatch - для частичного обновления

# Разделение моделей по назначению следует принципам REST API

# Пользователи:
# RegisterPayload - строгая валидация при регистрации

# LoginPayload - минимальные данные для входа

# UserUpdate - только изменяемые поля профиля

# Настройка приложения FastAPI:
# CORS Middleware:
# Критически важен для разработки с отдельными фронтенд/бэкенд серверами

# Точно настроенные origins для Vite dev и preview серверов

# Либеральные настройки для разработки (* для методов и заголовков)

# Статические файлы:
# Прямой доступ к загруженным изображениям через URL

# Не требует программирования отдельных эндпоинтов для каждого файла

# Аутентификация:
# HTTP Basic Auth - простой но эффективный механизм

# Dependency Injection - чистая архитектура FastAPI

# Гранулярные ошибки - разные сообщения для разных случаев сбоя

# Совместимость - поддержка legacy паролей с автоматической миграцией

# Эта архитектура обеспечивает надежную валидацию данных, безопасную аутентификацию и удобство разработки как для бэкенда так и для фронтенда.

# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================





# ===== СЛУЖЕБНЫЕ ЭНДПОИНТЫ =====

@app.get("/health")
def health():
    """
    Эндпоинт для проверки работоспособности API (health check).
    
    Назначение:
        - Мониторинг состояния сервиса (например, системными администраторами)
        - Проверка доступности API для балансировщиков нагрузки
        - Тестирование подключения к серверу во время разработки
        
    Возвращает:
        {"status": "ok"} - если сервер работает нормально
        
    Особенности:
        - Самый простой эндпоинт, не требует аутентификации
        - Не обращается к базе данных или другим внешним зависимостям
        - Быстрый отклик для мгновенной диагностики
    """
    return {"status": "ok"}


# ===== ЭНДПОИНТЫ АВТОРИЗАЦИИ =====

@app.post("/register", status_code=201)
def register_user(p: RegisterPayload):
    """
    Регистрация нового пользователя в системе.
    
    Процесс регистрации:
        1. Проверка уникальности логина
        2. Создание нового ID пользователя
        3. Хеширование пароля для безопасного хранения
        4. Сохранение пользователя в хранилище
        
    Args:
        p (RegisterPayload): Данные для регистрации из тела запроса
        
    Returns:
        dict: Результат регистрации в формате {"ok": True, "created_id": new_id}
        
    Raises:
        HTTPException: 409 Conflict если логин уже занят
        
    Безопасность:
        - Пароль никогда не сохраняется в открытом виде
        - Используется pbkdf2 хеширование для защиты паролей
        - Возвращается только ID пользователя, без чувствительных данных
    """
    # Проверка что логин не занят другим пользователем
    if USERS.login_exists(p.login):
        raise HTTPException(
            status_code=409, 
            detail="Логин уже занят"
        )

    # Генерация нового уникального ID для пользователя
    new_id = USERS.next_user_id()
    
    # Создание объекта пользователя с безопасным хранением пароля
    user_obj = {
        "name": p.name,           # Отображаемое имя пользователя
        "login": p.login,         # Уникальный логин для входа
        "email": p.email,         # Email (может быть None)
        # Аватар: либо переданный пользователем, либо стандартное изображение
        "ava": p.ava or "https://cdn.pixabay.com/photo/2015/10/05/22/37/blank-profile-picture-973460_640.png",
        # Пароль хранится только в виде хеша для безопасности
        "passwordHash": hash_password(p.password),
    }
    
    # Сохранение пользователя в постоянное хранилище
    USERS.save_user(new_id, user_obj)
    
    # Возврат успешного результата с ID нового пользователя
    return {"ok": True, "created_id": new_id}

@app.post("/login")
def login_user(p: LoginPayload):
    """
    Аутентификация пользователя в системе.
    
    Процесс входа:
        1. Поиск пользователя по логину
        2. Проверка корректности пароля
        3. Генерация токена сессии (временный, для демо-режима)
        4. Возврат безопасных данных пользователя (без пароля)
        
    Args:
        p (LoginPayload): Данные для входа (логин и пароль)
        
    Returns:
        dict: Результат аутентификации с пользователем и токеном
        
    Raises:
        HTTPException: 401 Unauthorized при неверных учетных данных
        
    Особенности безопасности:
        - Поддерживает миграцию с plaintext паролей на хешированные
        - Возвращает только безопасные данные пользователя (без passwordHash)
        - В продакшене следует использовать JWT вместо простого токена
    """
    # Поиск пользователя по логину в хранилище
    found = find_user_by_login(USERS, p.login)
    if not found:
        # Не сообщаем точно что неверно - логин или пароль (безопасность)
        raise HTTPException(
            status_code=401, 
            detail="Неверные учетные данные"
        )

    # Распаковка найденного пользователя (ID и данные)
    user_id, user = found
    
    # Проверка пароля с поддержкой legacy-миграции
    # Функция check_user_password может автоматически мигрировать plaintext пароли в хеши
    if not check_user_password(user_id, user, p.password, USERS):
        raise HTTPException(
            status_code=401, 
            detail="Неверные учетные данные"
        )

    # Генерация временного токена (в продакшене заменить на JWT)
    # uuid4().hex создает случайную строку из 32 символов
    token = f"dev-{uuid4().hex}"
    
    # Создание безопасного объекта пользователя без чувствительных данных
    safe_user = {
        "id": user_id,                    # ID пользователя
        "name": user.get("name"),         # Отображаемое имя
        "login": user.get("login"),       # Логин
        "ava": user.get("ava"),           # URL аватара
        "email": user.get("email"),       # Email
        # НЕ включаем: passwordHash, внутренние служебные поля
    }
    
    # Возврат успешного результата аутентификации
    return {
        "ok": True, 
        "user": safe_user,   # Безопасные данные пользователя
        "token": token       # Токен для последующих запросов
    }


# Подробное объяснение логики работы:
# Эндпоинт /health:
# Назначение в продакшене:
# Load Balancers - проверяют какой сервер жив и может принимать трафик

# Kubernetes - для liveness и readiness probes

# Мониторинг - системы типа Prometheus проверяют доступность сервиса

# DevOps - быстрая диагностика проблем в продакшене

# Минималистичная реализация:
# Не проверяет базу данных - только что приложение запущено

# Быстрый отклик (< 1ms)

# Нет внешних зависимостей

# Эндпоинт /register:
# Процесс регистрации:
# Валидация уникальности - предотвращает дубликаты логинов

# Генерация ID - автоматическое назначение уникального идентификатора

# Безопасное хранение пароля - только хеш, никогда оригинал

# Умолчания - стандартный аватар если не указан

# Обработка ошибок:
# 409 Conflict - четкое сообщение что логин занят

# Автоматическая валидация - Pydantic проверяет обязательные поля до вызова функции

# Безопасность:
# Никогда не логируем пароли

# Хеширование на сервере - клиент отправляет пароль в открытом виде по HTTPS

# PBKDF2 - современный алгоритм хеширования с "солью"

# Эндпоинт /login:
# Процесс аутентификации:
# Поиск пользователя - по логину в хранилище

# Проверка пароля - с поддержкой миграции старых паролей

# Генерация токена - временное решение для демо

# Возврат безопасных данных - фильтрация чувствительной информации

# Legacy-миграция паролей:

# # Примерная логика функции check_user_password:
# # 1. Если есть passwordHash - проверяем через hash_verify
# # 2. Если нет passwordHash, но пароль совпадает с plaintext в старом поле - 
# #    хешируем пароль и сохраняем, удаляем plaintext
# # 3. Если ничего не совпадает - возвращаем False

# Безопасные практики:
# Общие сообщения об ошибке - "Неверные учетные данные" вместо уточнения что именно неверно

# Без чувствительных данных в ответе - никогда не возвращаем passwordHash

# Временные токены - в продакшене заменить на JWT с expiration

# Токен в демо-режиме:
# dev-{uuid} - префикс указывает что это development токен

# Нет expiration - в продакшене добавить срок действия

# Нет подписи - в продакшене использовать JWT с cryptographic signature

# Эта реализация обеспечивает безопасную регистрацию и аутентификацию с защитой от распространенных уязвимостей и поддержкой постепенного улучшения системы безопасности.

# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================





# ===== CRUD ОПЕРАЦИИ СО СТАТЬЯМИ =====
# Этот раздел содержит все эндпоинты для работы со статьями (Create, Read, Update, Delete)

@app.get("/articles")
def list_articles(
    start: int = Query(0, ge=0),
    limit: int = Query(20, ge=1, le=100),
    q: Optional[str] = None,
    sort: Optional[Literal["id", "title", "author"]] = Query(None),
    dir: Optional[Literal["asc", "desc"]] = Query("desc"),
):
    """
    Получение списка статей с пагинацией, фильтрацией и сортировкой на стороне сервера.
    
    Параметры запроса:
        start (int): Смещение для пагинации (сколько элементов пропустить). По умолчанию 0.
        limit (int): Количество элементов на странице (от 1 до 100). По умолчанию 20.
        q (str): Строка для поиска по заголовку статьи (регистронезависимый).
        sort (str): Поле для сортировки: "id", "title" или "author". По умолчанию "id".
        dir (str): Направление сортировки: "asc" (по возрастанию) или "desc" (по убыванию). По умолчанию "desc".
    
    Returns:
        dict: Объект с общим количеством статей и списком статей для текущей страницы.
    
    Особенности:
        - Фильтрация происходит до сортировки и пагинации
        - Поддерживает сортировку по разным полям в обоих направлениях
        - Обрабатывает некорректные данные в статьях (безопасные функции сортировки)
    """
    # Загрузка всех статей из хранилища
    items = load_articles()

    # Фильтрация по заголовку если указан параметр q
    if q:
        ql = q.lower()  # Приводим поисковый запрос к нижнему регистру
        # Оставляем только статьи, в заголовке которых есть искомая подстрока
        items = [x for x in items if ql in str(x.get("title", "")).lower()]

    # Нормализация параметров сортировки (значения по умолчанию)
    key = (sort or "id").lower()  # Поле для сортировки, по умолчанию "id"
    reverse = (str(dir or "desc").lower() == "desc")  # Направление, по умолчанию убывание

    def safe_str(v):
        """
        Безопасное преобразование значения в строку для сортировки.
        
        Args:
            v: Любое значение
            
        Returns:
            str: Строковое представление значения или пустая строка если None
        """
        return str(v or "").casefold()  # casefold() для Unicode-безопасного сравнения

    def safe_int(v):
        """
        Безопасное преобразование значения в целое число для сортировки.
        
        Args:
            v: Любое значение
            
        Returns:
            int: Числовое представление или очень маленькое число при ошибке
        """
        try:
            return int(v)
        except Exception:
            # Возвращаем очень маленькое число чтобы "битые" ID оказались в конце при сортировке по убыванию
            return -10**12

    # Сортировка в зависимости от выбранного поля
    if key == "title":
        # Сортировка по заголовку (строковое сравнение)
        items.sort(key=lambda x: safe_str(x.get("title")), reverse=reverse)
    elif key == "author":
        # Сортировка по автору (строковое сравнение)
        items.sort(key=lambda x: safe_str(x.get("author")), reverse=reverse)
    else:  # "id" по умолчанию
        # Сортировка по ID (числовое сравнение)
        items.sort(key=lambda x: safe_int(x.get("id")), reverse=reverse)

    # Вычисление общего количества после фильтрации
    total = len(items)
    
    # Применение пагинации: берем срез от start до start+limit
    return {"total": total, "items": items[start:start + limit]}

@app.get("/articles/{article_id}")
def get_article(article_id: int):
    """
    Получение конкретной статьи по её ID.
    
    Args:
        article_id (int): Числовой идентификатор статьи
        
    Returns:
        dict: Объект статьи со всеми полями
        
    Raises:
        HTTPException: 404 если статья с указанным ID не найдена
        
    Особенности:
        - Преобразует ID статьи к int для сравнения (обработка строковых ID в хранилище)
        - Возвращает полный объект статьи включая mainInfo и mainContent
    """
    items = load_articles()
    for it in items:
        # Сравниваем ID, преобразуя оба значения к int для надежности
        if int(it.get("id", -1)) == article_id:
            return it
    # Если статья не найдена - возвращаем 404 ошибку
    raise HTTPException(status_code=404, detail="Article not found")

@app.post("/articles", status_code=201)
def create_article(payload: ArticleCreate, current=Depends(get_current_user)):
    """
    Создание новой статьи (требует авторизации).
    
    Args:
        payload (ArticleCreate): Данные для создания статьи из тела запроса
        current: Текущий авторизованный пользователь (из dependency)
        
    Returns:
        dict: Результат создания с ID новой статьи и её данными
        
    Процесс создания:
        1. Автоматическая генерация нового ID
        2. Привязка автора (author_id и author из данных пользователя)
        3. Сохранение в общий список статей
    """
    user_id, _user = current  # Получаем ID и данные текущего пользователя
    items = load_articles()   # Загружаем текущий список статей
    
    # Генерация нового уникального ID для статьи
    new_id = next_id(items)
    
    # Создание объекта статьи: объединяем сгенерированный ID с данными из запроса
    data = {"id": new_id, **payload.model_dump(exclude_unset=True)}
    
    # Заполнение информации об авторе
    data["author_id"] = user_id  # ID автора из аутентификации
    
    # Получаем данные пользователя для имени автора
    u = USERS.get(user_id) or {}
    # Используем имя пользователя, или логин, или "Unknown" как fallback
    data["author"] = u.get("name") or u.get("login") or "Unknown"
    
    # Добавляем новую статью в список и сохраняем
    items.append(data)
    save_articles(items)
    
    return {"ok": True, "id": new_id, "article": data}

@app.delete("/articles/{article_id}")
def delete_article(article_id: int, current=Depends(get_current_user)):
    """
    Удаление статьи и связанных с ней файлов изображений.
    
    Args:
        article_id (int): ID статьи для удаления
        current: Текущий авторизованный пользователь (из dependency)
        
    Returns:
        dict: Результат удаления с информацией об удаленных файлах
        
    Raises:
        HTTPException: 404 если статья или файл хранилища не найден
        HTTPException: 403 если пользователь не является автором статьи
        HTTPException: 500 если формат хранилища некорректный
        
    Процесс удаления:
        1. Проверка прав доступа (только автор может удалять)
        2. Сбор всех URL изображений связанных со статьей
        3. Удаление локальных файлов изображений
        4. Удаление статьи из хранилища
    """
    user_id, _user = current

    # Проверка существования файла со статьями
    if not ARTICLES_PATH.exists():
        raise HTTPException(status_code=404, detail="articles.json not found")

    # Чтение и парсинг файла статей
    with ARTICLES_PATH.open("r", encoding="utf-8") as f:
        data = json.load(f)

    # Поддержка двух форматов хранения: массив статей или объект с полем items
    items = data.get("items") if isinstance(data, dict) else data
    if not isinstance(items, list):
        raise HTTPException(status_code=500, detail="articles storage format error")

    # Поиск индекса статьи в списке
    idx = next((i for i, it in enumerate(items) if it.get("id") == article_id), None)
    if idx is None:
        raise HTTPException(status_code=404, detail="article not found")

    article = items[idx]  # Получаем найденную статью

    # Проверка прав доступа: только автор может удалять свою статью
    try_author = int(article.get("author_id", -1))
    if try_author != user_id:
        raise HTTPException(status_code=403, detail="Forbidden")

    # 1) Сбор всех URL изображений связанных со статьей
    urls: list[str] = []

    # Изображение превью статьи
    pv = article.get("previewImg")
    if isinstance(pv, str) and pv:
        urls.append(pv)

    # Основное изображение в блоке mainInfo
    mi = article.get("mainInfo") or {}
    if isinstance(mi, dict):
        mi_img = mi.get("image")
        if isinstance(mi_img, str) and mi_img:
            urls.append(mi_img)

    # Изображения в контентных блоках типа "image"
    blocks = article.get("mainContent") or []
    if isinstance(blocks, list):
        for b in blocks:
            if not isinstance(b, dict):
                continue
            if b.get("type") == "image":
                # Основное содержимое блока изображения
                v = b.get("content")
                if isinstance(v, str) and v:
                    urls.append(v)
                # Дополнительные возможные поля с URL изображений
                for k in ("src", "url", "href"):
                    vv = b.get(k)
                    if isinstance(vv, str) and vv:
                        urls.append(vv)

    # 2) Удаление локальных файлов изображений (только /uploads/...)
    result = delete_local_uploads(urls)
    
    # Обработка разных сигнатур функции delete_local_uploads
    if isinstance(result, tuple) and len(result) == 2:
        removed, candidates = result
    else:
        removed, candidates = result, urls  # fallback на случай другой сигнатуры

    # 3) Удаление статьи из хранилища
    items.pop(idx)
    
    # Обновление структуры данных в зависимости от формата хранения
    if isinstance(data, dict) and "items" in data:
        data["items"] = items
        # Обновление общего счетчика если он есть
        if "total" in data and isinstance(data["total"], int):
            data["total"] = max(0, data["total"] - 1)
        final = data
    else:
        final = items

    # Сохранение обновленных данных в файл
    with ARTICLES_PATH.open("w", encoding="utf-8") as f:
        json.dump(final, f, ensure_ascii=False, indent=2)

    return {
        "ok": True, 
        "removed": 1,                    # Количество удаленных статей
        "files_deleted": removed,        # Количество удаленных файлов
        "local_candidates": candidates   # Список проверенных URL
    }

@app.patch("/articles/{article_id}")
def patch_article(article_id: int, patch: ArticlePatch, current=Depends(get_current_user)):
    """
    Частичное обновление статьи (только для автора).
    
    Args:
        article_id (int): ID статьи для обновления
        patch (ArticlePatch): Данные для обновления (только изменяемые поля)
        current: Текущий авторизованный пользователь (из dependency)
        
    Returns:
        dict: Результат обновления с обновленной статьей
        
    Raises:
        HTTPException: 404 если статья не найдена
        HTTPException: 403 если пользователь не является автором
        
    Особенности:
        - Использует PATCH семантику - обновляются только переданные поля
        - exclude_unset=True игнорирует поля со значением None которые не были переданы
        - Сохраняет неизменными поля которые не были указаны в запросе
    """
    user_id, _user = current
    items = load_articles()

    # Поиск целевой статьи
    target = None
    for it in items:
        if int(it.get("id", -1)) == article_id:
            target = it
            break
    if not target:
        raise HTTPException(status_code=404, detail="Article not found")
    
    # Проверка что текущий пользователь - автор статьи
    if int(target.get("author_id", -1)) != user_id:
        raise HTTPException(status_code=403, detail="Forbidden")

    # Преобразование модели Pydantic в словарь, исключая непереданные поля
    p = patch.model_dump(exclude_unset=True)

    # Частичное обновление только переданных полей
    if "title" in p:
        target["title"] = p["title"]
    if "previewImg" in p:
        target["previewImg"] = p["previewImg"]
    if "mainInfo" in p:
        target["mainInfo"] = p["mainInfo"]
    if "mainContent" in p:
        target["mainContent"] = p["mainContent"]

    # Сохранение обновленного списка статей
    save_articles(items)
    return {"ok": True, "article": target}


# Подробное объяснение архитектуры CRUD операций:
# Эндпоинт GET /articles - Чтение с фильтрацией:
# Параметры запроса:
# start и limit - классическая пагинация offset/limit

# q - полнотекстовый поиск по заголовку (регистронезависимый)

# sort и dir - гибкая сортировка на стороне сервера

# Безопасная сортировка:
# safe_str() - обработка None значений и Unicode символов

# safe_int() - защита от некорректных ID с fallback значением

# Casefold сравнение - корректная работа с разными языками

# Производительность:
# Вся фильтрация и сортировка на сервере

# Подходит для небольших datasets (сотни статей)

# Для больших объемов потребуется база данных с индексами

# Эндпоинт GET /articles/{id} - Чтение одной статьи:
# Простая но надежная реализация:
# Линейный поиск по ID

# Преобразование типов для надежности

# Четкая 404 ошибка если не найдено

# Эндпоинт POST /articles - Создание статьи:
# Автоматическое заполнение:
# Генерация ID - последовательные числа

# Привязка автора - из данных аутентификации

# Имя автора - из профиля пользователя

# Безопасность:
# Требует аутентификации

# exclude_unset=True - игнорирует непереданные поля

# Эндпоинт DELETE /articles/{id} - Удаление статьи:
# Сложная логика очистки:
# Проверка прав - только автор может удалять

# Поиск связанных файлов - в preview, mainInfo и content блоках

# Удаление файлов - только локальные uploads

# Обновление хранилища - поддержка двух форматов

# Поддержка форматов хранения:

# // Формат 1: простой массив
# [
#   {"id": 1, "title": "Статья 1", ...},
#   {"id": 2, "title": "Статья 2", ...}
# ]

# // Формат 2: объект с метаданными
# {
#   "total": 2,
#   "items": [
#     {"id": 1, "title": "Статья 1", ...},
#     {"id": 2, "title": "Статья 2", ...}
#   ]
# }

# Эндпоинт PATCH /articles/{id} - Частичное обновление:

# PATCH семантика:
# Обновляются только переданные поля

# Неизменные поля сохраняют свои значения

# exclude_unset=True - ключевая особенность Pydantic

# Ограничения доступа:
# Только автор может редактировать статью

# Проверка author_id перед применением изменений

# Эта реализация обеспечивает полный CRUD функционал для статей с учетом безопасности, целостности данных и удобства использования.

# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================





# ===== СПЕЦИАЛЬНЫЕ ЭНДПОИНТЫ ДЛЯ РЕДАКТИРОВАНИЯ КОНТЕНТА (ПО ТЕХНИЧЕСКОМУ ЗАДАНИЮ) =====
# Эти эндпоинты предоставляют более специализированные операции для редактирования статей
# Они следуют принципу единственной ответственности и упрощают работу фронтенда

@app.put("/addContent/{article_id}")
def add_content(article_id: int, block: ContentItem, current=Depends(get_current_user)):
    """
    Добавление нового контентного блока в существующую статью.
    
    Args:
        article_id (int): ID статьи в которую добавляется блок
        block (ContentItem): Новый контентный блок для добавления
        current: Текущий авторизованный пользователь (из dependency)
        
    Returns:
        dict: Результат операции с обновленным списком контента
        
    Raises:
        HTTPException: 404 если статья не найдена
        HTTPException: 403 если пользователь не является автором статьи
        
    Процесс:
        1. Поиск статьи по ID
        2. Проверка прав доступа (только автор может редактировать)
        3. Добавление нового блока в конец списка mainContent
        4. Сохранение изменений и возврат обновленного контента
        
    Использование на фронтенде:
        - Для постепенного наполнения статьи блоками
        - Для добавления блоков через drag-and-drop интерфейс
        - Для инкрементального редактирования без перезаписи всего контента
    """
    user_id, _user = current  # Получаем ID текущего пользователя
    items = load_articles()   # Загружаем все статьи из хранилища
    
    # Поиск целевой статьи по ID
    for it in items:
        if int(it.get("id", -1)) == article_id:
            # Проверка что текущий пользователь - автор статьи
            if int(it.get("author_id", -1)) != user_id:
                raise HTTPException(status_code=403, detail="Forbidden")
            
            # Получаем текущий контент статьи или создаем пустой список
            content = it.get("mainContent") or []
            
            # Защита от некорректного типа данных (на случай повреждения хранилища)
            if not isinstance(content, list):
                content = []
            
            # Добавляем новый блок в конец списка контента
            # model_dump() преобразует Pydantic модель в словарь для хранения
            content.append(block.model_dump())
            
            # Обновляем контент статьи и сохраняем изменения
            it["mainContent"] = content
            save_articles(items)
            
            # Возвращаем успешный результат с обновленным контентом
            return {"ok": True, "mainContent": content}
    
    # Если статья не найдена - возвращаем ошибку 404
    raise HTTPException(status_code=404, detail="Article not found")

@app.put("/redoContent/{article_id}")
def redo_content(article_id: int, content: List[ContentItem], current=Depends(get_current_user)):
    """
    Полная перезапись всего контента статьи.
    
    Args:
        article_id (int): ID статьи для обновления
        content (List[ContentItem]): Полный новый список контентных блоков
        current: Текущий авторизованный пользователь (из dependency)
        
    Returns:
        dict: Результат операции с новым списком контента
        
    Raises:
        HTTPException: 404 если статья не найдена
        HTTPException: 403 если пользователь не является автором
        
    Особенности:
        - Полностью заменяет существующий mainContent на новый
        - Подходит для массового редактирования или импорта контента
        - Используется когда фронтенд работает со всем контентом сразу
        
    Отличие от addContent:
        - addContent добавляет один блок, redoContent заменяет все блоки
        - addContent - инкрементальное обновление, redoContent - полная замена
    """
    user_id, _user = current
    items = load_articles()
    
    # Поиск целевой статьи
    for it in items:
        if int(it.get("id", -1)) == article_id:
            # Проверка прав доступа
            if int(it.get("author_id", -1)) != user_id:
                raise HTTPException(status_code=403, detail="Forbidden")
            
            # Полная замена всего контента статьи
            # Преобразуем каждый ContentItem в словарь для хранения
            it["mainContent"] = [c.model_dump() for c in content]
            
            # Сохраняем изменения
            save_articles(items)
            
            # Возвращаем новый контент
            return {"ok": True, "mainContent": it["mainContent"]}
    
    raise HTTPException(status_code=404, detail="Article not found")

@app.put("/changeInfo/{article_id}")
def change_info(article_id: int, info: MainInfo, current=Depends(get_current_user)):
    """
    Обновление основной информации (MainInfo) о персонаже/сущности в статье.
    
    Args:
        article_id (int): ID статьи для обновления
        info (MainInfo): Новая основная информация
        current: Текущий авторизованный пользователь (из dependency)
        
    Returns:
        dict: Результат операции с обновленной основной информацией
        
    Raises:
        HTTPException: 404 если статья не найдена
        HTTPException: 403 если пользователь не является автором
        
    Особенности:
        - Использует exclude_unset=True для частичного обновления
        - Позволяет обновлять только переданные поля MainInfo
        - Сохраняет существующие значения непереданных полей
        
    Использование:
        - Редактирование характеристик персонажа Warhammer 40,000
        - Обновление статистик юнитов или фракций
        - Изменение основной информации без касания контента статьи
    """
    user_id, _user = current
    items = load_articles()
    
    # Поиск целевой статьи
    for it in items:
        if int(it.get("id", -1)) == article_id:
            # Проверка прав доступа
            if int(it.get("author_id", -1)) != user_id:
                raise HTTPException(status_code=403, detail="Forbidden")
            
            # Обновление основной информации с сохранением непереданных полей
            # exclude_unset=True - ключевая особенность: обновляются только явно переданные поля
            # Поля со значением None которые не были переданы - сохраняются
            it["mainInfo"] = info.model_dump(exclude_unset=True)
            
            # Сохраняем изменения
            save_articles(items)
            
            # Возвращаем обновленную основную информацию
            return {"ok": True, "mainInfo": it["mainInfo"]}
    
    raise HTTPException(status_code=404, detail="Article not found")


# Подробное объяснение архитектуры специализированных эндпоинтов:
# Общая концепция:
# Эти эндпоинты предоставляют более гранулярный контроль над редактированием статей по сравнению с общим PATCH /articles/{id}. Они следуют принципу Command Query Responsibility Segregation (CQRS) - разделение операций изменения и запросов.

# Эндпоинт PUT /addContent/{article_id}:
# Назначение:
# Инкрементальное добавление - добавление одного блока за раз

# UI-дружественный - идеально для пошагового редактирования

# Без потери данных - существующий контент сохраняется

# Типичные сценарии использования:

# // Фронтенд последовательно добавляет блоки:
# await addContent(1, {type: "h1", content: "Заголовок"})
# await addContent(1, {type: "p", content: "Абзац текста"})
# await addContent(1, {type: "image", content: "/uploads/image.jpg"})
# Защита от ошибок:
# Проверка типа isinstance(content, list) - защита от поврежденных данных

# Инициализация по умолчанию or [] - если контента еще нет

# Эндпоинт PUT /redoContent/{article_id}:

# Назначение:
# Атомарная замена - вся работа за один запрос

# Импорт/экспорт - удобно для массовых операций

# Undo/Redo - основа для функционала отмены действий

# Отличие от PATCH:
# Специализированный - работает только с mainContent

# Более простой API - фронтенд не нужно манипулировать отдельными полями

# Гарантированная целостность - либо все блоки обновляются, либо ничего

# Преобразование данных:

# # Преобразование List[ContentItem] в List[dict] для хранения
# [c.model_dump() for c in content]

# Эндпоинт PUT /changeInfo/{article_id}:

# Назначение:
# Редактирование метаданных - характеристик персонажей/сущностей

# Изолированное обновление - не затрагивает основной контент

# Частичное обновление - можно менять отдельные поля MainInfo

# Важность exclude_unset=True:

# # Если фронтенд отправляет только { "name": "Новое имя" }
# # то в хранилище сохранится:
# {
#     "name": "Новое имя",
#     # остальные поля (age, height, etc.) остаются неизменными
# }

# Структура MainInfo для Warhammer 40,000:

# {
#   "name": "Магнус Красный",
#   "age": 10000,
#   "gender": "Male", 
#   "height": "4.5m",
#   "appearance": "Гигантский воин в синих доспехах с одним глазом",
#   "other": {
#     "faction": "Thousand Sons",
#     "rank": "Primarch",
#     "homeworld": "Prospero"
#   }
# }

# Преимущества специализированных эндпоинтов:
# Для фронтенд-разработки:
# Более простые запросы - не нужно отправлять всю статью для мелких изменений

# Лучшая производительность - меньший объем передаваемых данных

# Упрощенная логика - каждая операция имеет четкое назначение

# Для бэкенд-логики:
# Более точная валидация - каждый эндпоинт валидирует конкретный тип данных

# Лучший контроль доступа - можно иметь разные права для разных операций

# Проще тестировать - изолированная функциональность

# Для пользовательского опыта:
# Более отзывчивый интерфейс - мгновенное сохранение отдельных изменений

# Снижение риска потери данных - меньше шансов конфликтов редактирования

# Специализированные UI - разные интерфейсы для редактирования контента и метаданных

# Эти эндпоинты делают API более предсказуемым и удобным для использования в Rich Text Editor и других сложных интерфейсах редактирования контента.

# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================


# ===== ЭНДПОИНТЫ ПРОФИЛЯ ПОЛЬЗОВАТЕЛЯ =====
# Этот раздел содержит эндпоинты для работы с профилем пользователя и его статьями
# Все эндпоинты требуют аутентификации пользователя

@app.get("/myProfile")
def my_profile(current=Depends(get_current_user)):
    """
    Получение профиля текущего аутентифицированного пользователя со статистикой.
    
    Args:
        current: Текущий авторизованный пользователь (из dependency)
        
    Returns:
        dict: Объект профиля пользователя с основной информацией и статистикой
        
    Содержимое профиля:
        - Основные данные пользователя (id, name, ava)
        - Статистика по статьям (количество authored и total в системе)
        - Совместимость со старым фронтендом (дублирование user_id)
        
    Особенности:
        - Всегда возвращает актуальные данные из хранилища
        - Считает статистику в реальном времени
        - Объединяет данные из двух хранилищ: пользователи и статьи
    """
    user_id, _user = current  # Получаем ID текущего пользователя
    items = load_articles()   # Загружаем все статьи для подсчета статистики
    
    # Фильтруем статьи, оставляя только те, где author_id совпадает с текущим пользователем
    mine = [x for x in items if int(x.get("author_id", -1)) == user_id]
    
    # Загружаем актуальные данные пользователя из хранилища
    u = USERS.get(user_id) or {}
    
    # Определяем отображаемое имя: приоритет у name, затем login, затем "Unknown"
    name = u.get("name") or u.get("login") or "Unknown"
    
    # Получаем аватар пользователя (может быть None)
    ava = u.get("ava")
    
    # Формируем объект профиля
    res = {
        "id": user_id,             # Уникальный идентификатор пользователя (новое поле)
        "name": name,              # Отображаемое имя пользователя
        "user_id": user_id,        # Дублирование ID для совместимости со старым фронтендом
        "authored": len(mine),     # Количество статей, созданных пользователем
        "totalArticles": len(items), # Общее количество статей в системе
    }
    
    # Добавляем аватар только если он есть (опциональное поле)
    if ava:
        res["ava"] = ava
        
    return res

@app.get("/myArticles")
def my_articles(current=Depends(get_current_user)):
    """
    Получение всех статей, созданных текущим пользователем.
    
    Args:
        current: Текущий авторизованный пользователь (из dependency)
        
    Returns:
        dict: Объект с общим количеством и списком статей пользователя
        
    Особенности:
        - Возвращает только статьи где author_id совпадает с текущим пользователем
        - Использует ту же структуру что и /articles для консистентности
        - Подходит для отображения "Мои статьи" в личном кабинете
        
    Отличие от /articles:
        - /articles возвращает все статьи (с фильтрацией)
        - /myArticles возвращает только статьи текущего пользователя
    """
    user_id, _user = current
    
    # Загружаем все статьи из хранилища
    items = load_articles()
    
    # Фильтруем статьи по author_id текущего пользователя
    # Используем int() преобразование для надежного сравнения
    mine = [x for x in items if int(x.get("author_id", -1)) == user_id]
    
    # Возвращаем в том же формате что и /articles для консистентности API
    return {"total": len(mine), "items": mine}

@app.put("/updateUser")
def update_user(p: UserUpdate, current=Depends(get_current_user)):
    """
    Обновление данных профиля текущего пользователя.
    
    Args:
        p (UserUpdate): Данные для обновления (имя и/или аватар)
        current: Текущий авторизованный пользователь (из dependency)
        
    Returns:
        dict: Обновленный профиль пользователя (через вызов my_profile)
        
    Особенности:
        - Обновляет только переданные поля (частичное обновление)
        - Валидация имени: игнорирует пустые строки и пробелы
        - Автоматически возвращает обновленный профиль
        - Использует upsert для безопасного обновления
        
    Валидация:
        - name: проверка на непустую строку после trim()
        - ava: принимает любой строковый URL (локальный или внешний)
    """
    user_id, _user = current
    
    # Создаем словарь для частичного обновления
    patch: Dict[str, Any] = {}
    
    # Обработка имени: обновляем только если передано непустое значение
    if p.name is not None and str(p.name).strip():
        # Удаляем пробелы по краям и сохраняем
        patch["name"] = str(p.name).strip()
    
    # Обработка аватара: обновляем если передан любой значение (включая пустую строку)
    if p.ava is not None:
        patch["ava"] = p.ava
    
    # Выполняем частичное обновление пользователя в хранилище
    # upsert гарантирует что поля будут обновлены, а остальные сохранены
    USERS.upsert(user_id, patch)
    
    # Возвращаем обновленный профиль, вызывая функцию my_profile
    # Это гарантирует что фронтенд получит актуальные данные
    return my_profile(current=current)


# Подробное объяснение архитектуры профиля пользователя:
# Эндпоинт GET /myProfile - Полный профиль со статистикой:
# Назначение:
# Личный кабинет - основная информация для страницы профиля

# Панель управления - статистика для авторов

# Валидация прав - подтверждение что пользователь вошел в систему

# Структура ответа:

# {
#   "id": 42,
#   "name": "Император Человечества",
#   "user_id": 42,
#   "authored": 15,
#   "totalArticles": 287,
#   "ava": "/uploads/emperor_avatar.jpg"
# }

# Совместимость с фронтендом:
# id и user_id - дублирование для обратной совместимости

# Постепенная миграция - старый фронтенд использует user_id, новый - id

# Опциональные поля - ava присутствует только если установлен

# Бизнес-логика статистики:
# authored - мотивация для авторов (виден собственный вклад)

# totalArticles - общий контекст (какая часть системы создана пользователем)

# Реальное время - всегда актуальные данные

# Эндпоинт GET /myArticles - Персональные статьи:
# Назначение:
# Быстрый доступ к своим статьям без фильтрации

# Управление контентом - просмотр, редактирование, удаление

# Изолированные данные - только свой контент

# Оптимизация производительности:
# Фильтрация на сервере - клиент не получает лишние данные

# Линейный поиск - приемлемо для сотен статей

# Кеширование - потенциально на фронтенде

# Консистентность API:

# // Одинаковая структура для /articles и /myArticles
# const allArticles = await fetch('/articles?q=space').then(r => r.json());
# const myArticles = await fetch('/myArticles').then(r => r.json());

# // Оба возвращают: { total: number, items: Article[] }

# Эндпоинт PUT /updateUser - Обновление профиля:
# Безопасное обновление:
# Частичное обновление - можно менять имя или аватар отдельно

# Валидация ввода - защита от пустых имен

# Санітазация - trim() для удаления пробелов

# Сценарии использования:

# // Смена имени
# await updateUser({ name: "Новое имя" })

# // Смена аватара  
# await updateUser({ ava: "/uploads/new_avatar.jpg" })

# // Смена имени и аватара
# await updateUser({ 
#   name: "Новое имя",
#   ava: "/uploads/new_avatar.jpg"
# })

# Обработка граничных случаев:
# Пустое имя - игнорируется если переданы только пробелы

# null значения - явная проверка is not None

# Совместимость типов - преобразование str(p.name)

# Архитектура ответа:
# Автоматическое обновление - возвращает свежий профиль

# Согласованность данных - фронтенд всегда в актуальном состоянии

# Экономия запросов - не нужно делать дополнительный GET после PUT

# Преимущества такой архитектуры:
# Для пользовательского опыта:
# Быстрая загрузка - профиль и статьи разделены

# Интуитивное управление - четкое разделение операций

# Мгновенная обратная связь - обновление профиля сразу отображается

# Для разработки:
# REST-совместимость - четкое разделение ресурсов

# Простота тестирования - изолированные функции

# Масштабируемость - можно добавлять новую статистику без ломания API

# Для безопасности:
# Автоматическая аутентификация - через dependency

# Изоляция данных - пользователи видят только свои статьи

# Валидация на стороне сервера - защита от некорректных данных

# Эта реализация обеспечивает полнофункциональную систему профилей с учетом потребностей пользователей, 
# требований безопасности и удобства разработки.

# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================





# ===== ЭНДПОИНТЫ ДЛЯ РАБОТЫ С ИЗОБРАЖЕНИЯМИ =====
# Этот раздел содержит все эндпоинты для загрузки, управления и обслуживания изображений
# Изображения являются ключевой частью вики по вселенной Warhammer 40,000

@app.post("/upload-image")
async def upload_image(file: UploadFile = File(...)):
    """
    Загрузка изображения на сервер с валидацией и обработкой.
    
    Args:
        file (UploadFile): Файл изображения из формы загрузки
        
    Returns:
        dict: Объект с URL загруженного изображения
        
    Raises:
        HTTPException: 400 если файл пустой
        HTTPException: 413 если файл превышает максимальный размер
        HTTPException: 415 если тип файла не поддерживается
        
    Процесс загрузки:
        1. Чтение файла в память
        2. Проверка размера файла
        3. Определение и валидация расширения
        4. Генерация уникального имени
        5. Сохранение на диск
        6. Возврат URL для доступа к файлу
    """
    # Читаем весь файл в память (асинхронно)
    raw = await file.read()
    
    # Проверка что файл не пустой
    if not raw:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, 
            detail="Пустой файл"
        )
    
    # Проверка размера файла (5 МБ согласно ТЗ)
    if len(raw) > MAX_INMEMORY:
        raise HTTPException(
            status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE, 
            detail="Слишком большой файл (макс. 5 МБ)"
        )

    # Определяем расширение файла из оригинального имени
    ext = Path(file.filename or "").suffix.lower()
    
    # Если расширение не в списке разрешенных, пытаемся определить по MIME-типу
    if ext not in ALLOWED_EXTS:
        mime = (file.content_type or "").lower()
        
        # Сопоставление MIME-типов с расширениями
        if "svg" in mime: 
            ext = ".svg"
        elif "png" in mime: 
            ext = ".png"
        elif "jpeg" in mime or "jpg" in mime: 
            ext = ".jpg"
        elif "webp" in mime: 
            ext = ".webp"
        elif "gif" in mime: 
            ext = ".gif"
        else:
            # Если тип не распознан - возвращаем ошибку
            raise HTTPException(
                status_code=status.HTTP_415_UNSUPPORTED_MEDIA_TYPE, 
                detail="Недопустимый тип файла"
            )

    # Генерация уникального имени файла чтобы избежать коллизий
    name = f"{uuid4().hex}{ext}"
    
    # Полный путь к файлу на диске
    dest = UPLOAD_DIR / name
    
    # Сохранение файла на диск
    dest.write_bytes(raw)
    
    # Возвращаем URL по которому файл будет доступен
    return {"url": f"/uploads/{name}"}

@app.get("/uploads/_debug")
def uploads_debug():
    """
    Отладочный эндпоинт для просмотра состояния директории с загруженными файлами.
    
    Returns:
        dict: Информация о файлах в директории uploads
        
    Назначение:
        - Мониторинг использования дискового пространства
        - Отладка проблем с загрузкой файлов
        - Проверка что файлы сохраняются корректно
        
    Особенности:
        - Возвращает только первые 50 файлов чтобы не перегружать ответ
        - Показывает полный путь к директории для диагностики
        - Обрабатывает ошибки доступа к файловой системе
    """
    try:
        # Получаем список файлов в директории uploads
        # sorted() для удобства чтения, is_file() чтобы исключить директории
        files = sorted([p.name for p in UPLOAD_DIR.iterdir() if p.is_file()])
    except Exception as e:
        # В случае ошибки (например, нет прав доступа) возвращаем информацию об ошибке
        return {
            "ok": False, 
            "error": str(e), 
            "path": str(UPLOAD_DIR)
        }
    
    # Возвращаем успешный результат с информацией о файлах
    return {
        "ok": True, 
        "path": str(UPLOAD_DIR),      # Полный путь к директории
        "count": len(files),          # Общее количество файлов
        "files": files[:50]           # Список файлов (первые 50)
    }

@app.post("/images/fromUrl")
async def image_from_url(url: str):
    """
    Загрузка изображения по URL из внешнего источника.
    
    Args:
        url (str): URL изображения для загрузки
        
    Returns:
        dict: Объект с локальным URL загруженного изображения
        
    Raises:
        HTTPException: 400 если не удалось скачать изображение
        HTTPException: 413 если размер изображения превышает лимит
        
    Процесс:
        1. HTTP-запрос к внешнему URL
        2. Проверка успешности запроса
        3. Определение типа изображения по Content-Type
        4. Проверка размера
        5. Сохранение в локальную директорию
        6. Возврат локального URL
        
    Использование:
        - Импорт изображений из других вики-ресурсов по Warhammer 40,000
        - Копирование изображений с официальных сайтов Games Workshop
        - Миграция контента из других систем
    """
    # Настройка таймаута для HTTP-запроса (10 секунд на соединение и чтение)
    timeout = httpx.Timeout(10.0, connect=10.0)
    
    try:
        # Создаем асинхронный HTTP-клиент
        async with httpx.AsyncClient(timeout=timeout, follow_redirects=True) as client:
            # Выполняем GET-запрос к указанному URL
            r = await client.get(url)
            # Проверяем что запрос успешен (статус 200-299)
            r.raise_for_status()
            
            # Определяем тип изображения по заголовку Content-Type
            content_type = r.headers.get("content-type", "").lower()
            ext = ".jpg"  # Значение по умолчанию
            
            # Сопоставляем MIME-тип с расширением файла
            if "png" in content_type: 
                ext = ".png"
            elif "webp" in content_type: 
                ext = ".webp"
            elif "gif" in content_type: 
                ext = ".gif"
            elif "svg" in content_type: 
                ext = ".svg"
            
            # Получаем бинарное содержимое изображения
            data = r.content
            
    except Exception:
        # Если произошла любая ошибка (таймаут, 404, etc.) - возвращаем ошибку
        raise HTTPException(
            status_code=400, 
            detail="Не удалось скачать изображение"
        )

    # Проверяем размер загруженного изображения
    if len(data) > MAX_INMEMORY:
        raise HTTPException(
            status_code=413, 
            detail="Слишком большой файл (макс. 5 МБ)"
        )

    # Генерация уникального имени и сохранение файла
    name = f"{uuid4().hex}{ext}"
    (UPLOAD_DIR / name).write_bytes(data)
    
    return {"url": f"/uploads/{name}"}

@app.get("/images/proxy")
def image_proxy(url: str):
    """
    Прокси-эндпоинт для обработки URL изображений.
    
    Args:
        url (str): URL изображения для обработки
        
    Returns:
        dict: Объект с URL изображения (оригинальный или обработанный)
        
    Логика работы:
        - Если URL уже локальный (/uploads/...) - возвращает как есть
        - Если URL внешний - возвращает оригинальный URL
        - В будущем может добавлять обработку внешних URL (кеширование, ресайз)
        
    Назначение:
        - Единая точка входа для работы с изображениями на фронтенде
        - Возможность добавления дополнительной логики в будущем
        - Абстракция от способа хранения изображений
    """
    # Если URL уже указывает на локальную директорию uploads - возвращаем как есть
    if url.startswith("/uploads/"):
        return {"url": url}
    
    # Для внешних URL пока просто возвращаем оригинальный URL
    # В будущем здесь может быть логика кеширования или обработки
    return {"url": url}

# Совместимость со старым фронтом
@app.post("/upload")
async def upload_image_compat(file: UploadFile = File(...)):
    """
    Эндпоинт для обратной совместимости со старым фронтендом.
    
    Args:
        file (UploadFile): Файл изображения для загрузки
        
    Returns:
        dict: Результат загрузки в том же формате что и /upload-image
        
    Назначение:
        - Поддержка старого фронтенда который использует /upload вместо /upload-image
        - Постепенная миграция без breaking changes
        - Полностью делегирует работу основной функции upload_image
    """
    return await upload_image(file)

# Подробное объяснение архитектуры работы с изображениями:
# Эндпоинт POST /upload-image - Основная загрузка:
# Безопасность и валидация:
# Размер файла - защита от переполнения диска

# Типы файлов - white-list подход только для изображений

# MIME-типы - дополнительная проверка помимо расширения

# Определение типа файла:

# # Иерархия проверок:
# # 1. Сначала по расширению файла (.jpg, .png, etc.)
# # 2. Затем по MIME-типу (image/jpeg, image/png, etc.)
# # 3. Если оба метода не сработали - ошибка

# Генерация имен:
# UUID4 - гарантирует уникальность имен

# Hex представление - только буквы и цифры, безопасно для URL

# Сохранение расширения - для корректного отображения браузером

# Эндпоинт GET /uploads/_debug - Диагностика:
# Для разработки и администрирования:
# Мониторинг использования - сколько файлов и места занимают

# Поиск проблем - проверка что файлы сохраняются

# Очистка - идентификация старых или ненужных файлов

# Ограничения:
# Только 50 файлов - защита от перегрузки при большом количестве файлов

# Только файлы - игнорирует поддиректории

# Сортировка - для удобства просмотра

# Эндпоинт POST /images/fromUrl - Импорт по URL:
# Сценарии использования для Warhammer 40,000:
# Импорт с официального сайта - warhammer-community.com

# Копирование из Lexicanum - lexicanum.com

# Миграция с Fandom - warhammer40k.fandom.com

# Настройки HTTP-клиента:
# Таймаут 10 секунд - защита от зависаний на медленных серверах

# Follow redirects - обработка перенаправлений

# Проверка статуса - только успешные ответы (200-299)

# Определение типа по Content-Type:

# # Приоритет отдается заголовку Content-Type над расширением в URL
# # Например: https://site.com/image?type=png может быть JPEG на самом деле

# Эндпоинт GET /images/proxy - Единая точка доступа:
# Архитектурные преимущества:
# Абстракция - фронтенд не знает где хранятся изображения

# Будущая расширяемость - можно добавить кеширование, ресайз, конвертацию

# Безопасность - контроль над тем какие URL разрешены

# Потенциальные улучшения:

# # В будущем можно добавить:
# - Кеширование внешних изображений
# - Автоматическую конвертацию в WebP
# - Ресайз под разные разрешения
# - Водяные знаки для защиты контента

# Эндпоинт POST /upload - Совместимость:
# Стратегия миграции API:
# Старый эндпоинт /upload - поддерживается для обратной совместимости

# Новый эндпоинт /upload-image - рекомендуемый для нового кода

# Одинаковая логика - оба вызывают одну функцию

# Постепенное обновление - фронтенд можно обновлять постепенно

# Безопасность и ограничения:
# Защита от злоупотреблений:

# Максимальный размер 5MB - защита от переполнения диска

# Только изображения - предотвращение загрузки исполняемых файлов

# Таймауты - защита от DDoS атак через медленные загрузки

# Управление дисковым пространством:
# Регулярная очистка - через эндпоинт удаления статей

# Мониторинг - через debug эндпоинт

# Автоматическое удаление - при удалении статей

# Интеграция с Warhammer 40,000 контентом:
# Типы изображений для вселенной:
# Персонажи - портреты примархов, space marines, xenos

# Техника - танки, корабли, оружие

# Карты - карты галактики, планет, сражений

# Символика - гербы фракций, знаки отличия

# Оптимизация для вики:

# Баланс качества и размера - 5MB достаточно для детализированных изображений

# Поддержка SVG - для векторной графики (гербы, символы)

# WebP поддержка - современный формат с хорошим сжатием

# Эта система обеспечивает надежную работу с изображениями, 
# которые являются ключевой частью вики по вселенной Warhammer 40,000, 
# предоставляя как базовые функции загрузки, так и расширенные возможности для импорта и управления контентом.

# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================


# ===== ОТКРЫТАЯ API СХЕМА =====

@app.get("/openapi.json")
def openapi_json():
    """
    Предоставление OpenAPI схемы API в JSON формате.
    
    Returns:
        dict: OpenAPI спецификация API в формате JSON
        
    Назначение:
        - Автоматическая генерация документации API
        - Интеграция с инструментами типа Swagger UI, ReDoc
        - Генерация клиентских библиотек для фронтенда
        - Тестирование и валидация API
        
    Особенности FastAPI:
        - Схема генерируется автоматически на основе типов Python и Pydantic моделей
        - Включает все эндпоинты, параметры, модели данных и ответы
        - Обновляется в реальном времени при изменении кода
        
    Использование:
        - Swagger UI: http://localhost:8000/docs
        - ReDoc: http://localhost:8000/redoc
        - Сырая схема: http://localhost:8000/openapi.json
    """
    return app.openapi()


# Подробное объяснение OpenAPI схемы в FastAPI:
# Что такое OpenAPI схема:
# OpenAPI (ранее Swagger) - это стандартный формат для описания RESTful API. FastAPI автоматически генерирует эту схему на основе:

# Декораторов маршрутов - @app.get(), @app.post(), etc.

# Pydantic моделей - для валидации запросов и ответов

# Типов Python - для определения формата данных

# Docstrings - для описания эндпоинтов и моделей

# Что содержится в OpenAPI схеме:

# {
#   "openapi": "3.1.0",
#   "info": {
#     "title": "deep_lom_ka API (PROJECT-DEEP_LOO_MKA)",
#     "version": "0.1.0"
#   },
#   "paths": {
#     "/articles": {
#       "get": {
#         "summary": "List Articles",
#         "description": "Получение списка статей с пагинацией, фильтрацией и сортировкой...",
#         "parameters": [...],
#         "responses": {
#           "200": {
#             "description": "Successful Response",
#             "content": {
#               "application/json": {
#                 "schema": {...}
#               }
#             }
#           }
#         }
#       }
#     }
#   },
#   "components": {
#     "schemas": {
#       "Article": {...},
#       "UserUpdate": {...},
#       // Все Pydantic модели автоматически включаются
#     }
#   }
# }

# Преимущества автоматической генерации:
# Для разработчиков API:
# Синхронизация документации и кода - документация всегда актуальна

# Скорость разработки - не нужно писать документацию вручную

# Валидация - схема помогает находить ошибки в структуре API

# Для фронтенд-разработчиков:
# Интерактивная документация - можно тестировать API прямо в браузере

# Генерация клиентского кода - инструменты могут создавать TypeScript-клиенты

# Понимание API - полная информация о всех эндпоинтах и данных

# Для проекта Warhammer 40,000 вики:
# Быстрый старт новых разработчиков - понятная документация API

# Стандартизация - единый формат для всех эндпоинтов

# Качество кода - строгая типизация уменьшает количество ошибок

# Инструменты которые используют OpenAPI схему:
# Swagger UI (/docs):
# Интерактивный интерфейс для тестирования API

# Автогенерация форм для отправки запросов

# Встроенная авторизация - можно ввести Basic Auth credentials

# ReDoc (/redoc):
# Красивая документация в стиле single-page

# Удобна для чтения - для конечных пользователей API

# Поиск по API - быстрый доступ к нужным эндпоинтам

# Генераторы клиентского кода:
# openapi-generator - генерация клиентов на TypeScript, Java, Python, etc.

# Autorest - для .NET клиентов

# Swagger Codegen - устаревший, но все еще используется

# Пример использования для фронтенда:

# // Автогенерация TypeScript клиента на основе openapi.json
# // Получаем полную типобезопасность при работе с API

# interface Article {
#   id: number;
#   title: string;
#   author: string;
#   previewImg?: string;
#   mainInfo?: MainInfo;
# }

# // Автогенерация функций API
# api.getArticles({ start: 0, limit: 20, sort: 'title' })
#   .then((response: { total: number, items: Article[] }) => {
#     // Полная типобезопасность - TypeScript знает структуру ответа
#   });

# Расширенные возможности FastAPI:
# Кастомизация схемы:

# app = FastAPI(
#     title="Warhammer 40,000 Wiki API",
#     description="API для фандомной вики по вселенной Warhammer 40,000",
#     version="1.0.0",
#     contact={
#         "name": "Project DEEP_LOO_MKA",
#         "url": "http://example.com",
#     },
#     license_info={
#         "name": "MIT",
#         "url": "https://opensource.org/licenses/MIT",
#     }
# )

# Дополнительные метаданные для эндпоинтов:

# @app.get(
#     "/articles",
#     summary="Список статей",
#     description="Получение списка статей с фильтрацией и сортировкой...",
#     response_description="Список статей с пагинацией",
#     tags=["Статьи"]
# )

# Для проекта Warhammer 40,000 вики:
# Структура документации:
# Группировка по тегам - "Аутентификация", "Статьи", "Пользователи", "Изображения"

# Примеры запросов - для основных сценариев использования

# Описание моделей - характеристики персонажей, фракций, юнитов

# Особенности для контента Warhammer:

# class MainInfo(BaseModel):
#     """Основная информация о сущности вселенной Warhammer 40,000"""
    
#     name: Optional[str] = Field(..., description="Имя персонажа или название сущности")
#     faction: Optional[str] = Field(..., description="Фракция: Imperium, Chaos, Xenos, etc.")
#     homeworld: Optional[str] = Field(..., description="Родной мир или планета")
#     # ... другие поля с описаниями

# Этот эндпоинт завершает API и предоставляет мощный инструмент для документации, 
# тестирования и интеграции, 
# что особенно важно для такого сложного проекта как вики по вселенной Warhammer 40,000 с 
# разнообразными типами контента и сложными связями между сущностями.

# ======================================================================================================================
# ======================================================================================================================
# ======================================================================================================================



