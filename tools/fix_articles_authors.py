# Скрипт для исправления согласованности данных авторов в статьях
# Одноразовая утилита для миграции и синхронизации данных

import json, os, sys

# Определение путей к файлам данных
ROOT = os.path.dirname(os.path.dirname(__file__))  # J:\MAIN_DIP-М\API\
DATA = os.path.join(ROOT, "data")                  # J:\MAIN_DIP-М\API\data
ART  = os.path.join(DATA, "articles.json")         # Файл со статьями
USR  = os.path.join(DATA, "users.json")            # Файл с пользователями

# Загрузка данных пользователей из users.json
users = json.load(open(USR, "r", encoding="utf-8"))

# Создание словаря для преобразования ID пользователя в отображаемое имя
# Формат: {user_id: display_name}
# Использует имя (name) если есть, иначе логин (login)
name_by_id = {int(k): (v.get("name") or v.get("login")) for k, v in users.items()}

# Создание обратного словаря для преобразования имени в ID пользователя
# Формат: {display_name: user_id}
# Важно: используется моржовый оператор := для присвоения в comprehension
id_by_name = {
    display: int(k)  # Ключ - отображаемое имя, значение - ID пользователя
    for k, v in users.items()
    if (display := (v.get("name") or v.get("login")))  # Проверка что имя не пустое
}

# Загрузка статей из articles.json
arts = json.load(open(ART, "r", encoding="utf-8"))
changed = 0  # Счетчик измененных статей

# Основной цикл обработки статей
for a in arts:
    # Получаем текущие значения author_id и author из статьи
    aid = a.get("author_id")  # ID автора (может быть None, int или другим типом)
    an  = a.get("author")     # Имя автора (строка или None)

    # СЛУЧАЙ 1: Есть author_id, но имя автора не соответствует
    # Если author_id корректен и есть в словаре, но имя автора не совпадает
    if isinstance(aid, int) and aid in name_by_id and an != name_by_id[aid]:
        a["author"] = name_by_id[aid]  # Обновляем имя автора по ID
        changed += 1  # Увеличиваем счетчик изменений

    # СЛУЧАЙ 2: Есть имя автора, но author_id не соответствует
    # Если имя автора есть в словаре, но author_id не совпадает
    elif isinstance(an, str) and an in id_by_name and aid != id_by_name[an]:
        a["author_id"] = id_by_name[an]  # Обновляем ID автора по имени
        changed += 1  # Увеличиваем счетчик изменений

    # СЛУЧАЙ 3: Нет ни author_id, ни author - критическая ошибка данных
    elif not aid and not an:
        print("! Статья без автора, id:", a.get("id"))

# Сохранение исправленных данных обратно в файл
json.dump(arts, open(ART, "w", encoding="utf-8"), ensure_ascii=False, indent=2)

# Вывод статистики
print("Правок:", changed)

# Зачем вообще этот скрипт? 
# Одноразовая утилита для синхронизации author ↔ author_id в старых/смешанных данных.

# Запуск при необходимости:
# python J:\MAIN_DIP-М\API\tools\fix_articles_authors.py 
# (предварительно сделаю копию articles.json — чисто на всякий).


# Подробное объяснение работы скрипта:

# Назначение скрипта:

# Этот скрипт решает проблему несогласованности данных между двумя системами идентификации авторов:

# author_id - числовой ID автора (связь с users.json)

# author - отображаемое имя автора (для показа пользователям)

# Проблемы которые исправляет скрипт:
# Случай 1: Несоответствие имени автора

# // До исправления:
# {
#   "id": 1,
#   "author_id": 42,
#   "author": "Старое Имя",  // Не соответствует текущему имени пользователя
#   "title": "Статья о Space Marines"
# }

# // После исправления (если пользователь 42 сейчас имеет имя "Новое Имя"):
# {
#   "id": 1, 
#   "author_id": 42,
#   "author": "Новое Имя",   // Автоматически обновлено
#   "title": "Статья о Space Marines"
# }

# Случай 2: Несоответствие ID автора

# // До исправления:
# {
#   "id": 2,
#   "author_id": 100,        // Неправильный ID для этого автора
#   "author": "Император",
#   "title": "Тактика Империума"
# }

# // После исправления (если "Император" имеет ID 1):
# {
#   "id": 2,
#   "author_id": 1,          // Исправлен на правильный ID
#   "author": "Император", 
#   "title": "Тактика Империума"
# }

# Случай 3: Полное отсутствие данных об авторе

# // Проблемная статья:
# {
#   "id": 3,
#   "author_id": null,      // Нет ID автора
#   "author": null,         // Нет имени автора  
#   "title": "Забытая статья"
# }
# // Выводится предупреждение: "! Статья без автора, id: 3"

# Технические детали реализации:

# Создание словарей преобразования:
# name_by_id - прямое преобразование:

# # Из users.json: {"1": {"name": "John", "login": "john"}, "2": {"login": "alice"}}
# # В name_by_id: {1: "John", 2: "alice"}

# id_by_name - обратное преобразование:

# # Из users.json: {"1": {"name": "John", "login": "john"}, "2": {"login": "alice"}}  
# # В id_by_name: {"John": 1, "alice": 2}

# Моржовый оператор (:=):

# # Без моржового оператора пришлось бы писать:
# id_by_name = {}
# for k, v in users.items():
#     display = v.get("name") or v.get("login")
#     if display:
#         id_by_name[display] = int(k)

# # С моржовым оператором - более компактно:
# id_by_name = {
#     display: int(k)
#     for k, v in users.items()
#     if (display := (v.get("name") or v.get("login")))
# }


# Сценарии использования в проекте Warhammer 40,000:
# Миграция со старой системы:
# В старой системе могли быть только имена авторов (без ID)

# При переходе на новую систему нужно добавить author_id

# Скрипт автоматически находит соответствия

# Исправление ручных правок:
# Администраторы могли вручную менять имена авторов

# При этом author_id мог устареть

# Скрипт восстанавливает корректные связи

# Обновление при изменении профилей:
# Пользователи меняют свои имена

# Старые статьи продолжают показывать старые имена

# Скрипт обновляет имена во всех статьях


# Меры предосторожности:
# Резервное копирование:

# # Перед запуском скрипта:
# cp articles.json articles.json.backup

# Проверка изменений:

# # После запуска проверяем:
# print("Правок:", changed)  # Должно быть разумное число

# Валидация данных:
# Скрипт проверяет типы данных (isinstance(aid, int))

# Игнорирует некорректные значения

# Сообщает о проблемных статьях

# Интеграция с основной системой:
# Этот скрипт не является частью основного приложения, а представляет собой инструмент миграции данных. Он используется:

# При первичном развертывании - для приведения данных в согласованное состояние

# После массовых изменений - при импорте данных из других систем

# Периодически - для поддержания целостности данных

# Скрипт демонстрирует профессиональный подход к управлению данными в проекте 
# вики по Warhammer 40,000, 
# обеспечивая согласованность и целостность информации об авторах статей.





