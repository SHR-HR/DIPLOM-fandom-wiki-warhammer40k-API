# Скрипт миграции паролей пользователей из plaintext в хешированные
# Одноразовая утилита для повышения безопасности системы

from __future__ import annotations
import json, shutil, sys
from pathlib import Path

# Определение путей к файлам
ROOT = Path(__file__).resolve().parents[1]  # J:\MAIN_DIP-М\API\
DATA = ROOT / "data"                         # Директория данных
USERS = DATA / "users.json"                  # Файл с пользователями
BACKUP = DATA / "users.backup.json"          # Файл для резервной копии

# Добавляем корневую директорию в путь для импорта модулей проекта
sys.path.insert(0, str(ROOT))
# Импортируем функцию хеширования паролей из основного приложения
from app.security import hash_password  # type: ignore

def main():
    """
    Основная функция скрипта миграции паролей.
    
    Процесс:
      1. Проверяет существование файла пользователей
      2. Создает резервную копию на случай проблем
      3. Загружает данные пользователей
      4. Находит пользователей с паролями в plaintext
      5. Заменяет plaintext пароли на хеши
      6. Сохраняет обновленные данные
    """
    # Проверка что файл users.json существует
    if not USERS.exists():
        print(f"[!] {USERS} не найден", file=sys.stderr)
        sys.exit(1)

    # Создание резервной копии файла пользователей
    shutil.copy2(USERS, BACKUP)
    print(f"[i] Бэкап → {BACKUP}")

    # Загрузка данных пользователей из JSON файла
    data = json.loads(USERS.read_text(encoding="utf-8"))
    changed = 0  # Счетчик мигрированных пользователей

    # Итерация по всем пользователям в формате: { "1": {...}, "2": {...} }
    for sid, u in list(data.items()):
        # Пропускаем некорректные записи (не словари)
        if not isinstance(u, dict):
            continue

        # Миграция plaintext пароля в хеш
        if u.get("password"):
            # Создаем хеш пароля используя ту же функцию что и в основном приложении
            u["passwordHash"] = hash_password(u["password"])
            # Удаляем старый пароль в открытом виде
            u.pop("password", None)
            changed += 1  # Увеличиваем счетчик изменений

    # Сохранение обновленных данных обратно в файл
    USERS.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"[✓] Готово. Мигрировано записей: {changed}")

if __name__ == "__main__":
    main()



# Подробное объяснение работы скрипта миграции:

# Назначение скрипта:

# Этот скрипт решает критическую проблему безопасности - хранение паролей в открытом виде (plaintext). Он выполняет одноразовую миграцию всех пользовательских паролей из незащищенного формата в безопасные хеши.



# Проблема безопасности:

# До миграции:

# {
#   "1": {
#     "login": "imperator",
#     "password": "secret123",  // Пароль в открытом виде - ОПАСНО!
#     "name": "Император Человечества"
#   }
# }


# После миграции:

# {
#   "1": {
#     "login": "imperator", 
#     "passwordHash": "pbkdf2_sha256$260000$abc123...",  // Безопасный хеш
#     "name": "Император Человечества"
#   }
# }



# Ключевые особенности реализации:

# Безопасность процесса:
# Резервное копирование - создается users.backup.json перед изменениями

# Использование той же функции хеширования что и в основном приложении

# Атомарные операции - либо все изменения применяются, либо ничего


# Импорт системы безопасности:

# # Важно использовать ТУ ЖЕ САМУЮ функцию hash_password что и в приложении
# # Это гарантирует что:
# # 1. Новые пользователи и мигрированные используют одинаковый алгоритм
# # 2. verify_password() будет корректно работать со всеми хешами
# from app.security import hash_password



# Процесс миграции:
# Шаг 1: Подготовка
# Проверка существования users.json

# Создание резервной копии с помощью shutil.copy2()

# Шаг 2: Обработка данных

# for sid, u in list(data.items()):
#     # sid - строковый ID пользователя ("1", "2", etc.)
#     # u - данные пользователя (словарь)
    
#     if u.get("password"):  # Если есть поле password (plaintext)
#         u["passwordHash"] = hash_password(u["password"])  # Создаем хеш
#         u.pop("password", None)  # Удаляем plaintext пароль
#         changed += 1  # Считаем изменение


# Шаг 3: Сохранение результатов
# Запись обновленных данных обратно в users.json

# Вывод статистики по количеству мигрированных записей


# Обработка крайних случаев:
# Некорректные данные:

# # Пропускаем записи которые не являются словарями
# if not isinstance(u, dict):
#     continue

# Пользователи без паролей:
# Пользователи без поля password просто пропускаются

# Возможно, у них уже есть passwordHash или это системные учетки

# Дублирование полей:
# Если случайно есть и password и passwordHash, приоритет у plaintext

# Старый password удаляется после создания хеша

# Интеграция с системой Warhammer 40,000 вики:
# Сценарии использования:
# Первоначальное развертывание:
# При первом запуске системы после импорта данных из старой системы

# Когда старая система хранила пароли в открытом виде

# Обнаружение уязвимости:
# Если обнаружилось что некоторые пароли все еще в plaintext

# Экстренная миграция для устранения угрозы безопасности

# Плановое обновление безопасности:
# Регулярный аудит безопасности системы

# Принудительная миграция оставшихся plaintext паролей

# Сообщения выполнения:

# [i] Бэкап → J:\MAIN_DIP-М\API\data\users.backup.json
# [✓] Готово. Мигрировано записей: 42
 

# Меры предосторожности:

# Резервное копирование:

# shutil.copy2() сохраняет метаданные файла

# Резервная копия создается в той же директории

# Имя users.backup.json ясно указывает на назначение файла

# Восстановление при проблемах:

# # Если что-то пошло не так, можно восстановить из бэкапа:
# backup_data = json.loads(BACKUP.read_text(encoding="utf-8"))
# USERS.write_text(json.dumps(backup_data, ensure_ascii=False, indent=2), encoding="utf-8")

# Валидация результата:
# Скрипт выводит количество измененных записей

# Можно проверить что число соответствует ожиданиям

# После миграции нужно проверить что пользователи могут войти в систему

# Безопасность после миграции:
# После выполнения этого скрипта система становится значительно безопаснее:

# Защита от утечек - даже при доступе к базе данных злоумышленник не получит пароли

# Следование best practices - никогда не хранить пароли в открытом виде

# Готовность к аудиту - можно продемонстрировать что пароли должным образом защищены

# Этот скрипт демонстрирует зрелый подход к безопасности в проекте вики по Warhammer 40,000, 
# обеспечивая плавный переход от уязвимой системы к защищенной без нарушения работы существующих пользователей.


